import React, { useState, useEffect } from 'react';
import { Button, Container, Row, Col, Table } from 'react-bootstrap';
import CONTRACT_ADDRESS from './config/contract-address';
import CONTRACT_ABI from './config/BabanukiNFT.json';
import Web3 from 'web3';

// web3Instance.jsで作成したWeb3インスタンスをインポート
//import web3 from './lib/web3Instance';


const App = () => {
  const [players, setPlayers] = useState([]);
  const [gameStarted, setGameStarted] = useState(false);
  const [turnPlayer, setTurnPlayer] = useState(null);
  const [finishedPlayers, setFinishedPlayers] = useState([]);
  const [remainingPlayers, setRemainingPlayers] = useState([]);

  const accounts = [
    "0x15d34AAf54267DB7D7c367839AAf71A00a2C6A65",
    "0x70997970C51812dc3A010C7d01b50e0d17dc79C8",
    "0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC",
    "0x90F79bf6EB2c4f870365E785982E1f101E93b906",
  ];


  // const executeNextPlayer = () => {
  //   const currentPlayer = players[turnPlayer];
  //   if (currentPlayer.hand.length === 0) {
  //     // Save the first player who has no more cards
  //     if (finishedPlayers.length === 0) {
  //       setFinishedPlayers([currentPlayer.id]);
  //     }
  //     // Move to the next player
  //     setTurnPlayer((turnPlayer + 1) % players.length);
  //     return;
  //   }
  //   // Find players who have not yet won
  //   const remainingPlayers = players.filter(player => player.hand.length > 0);
  //   if (remainingPlayers.length === 1) {
  //     console.log(`ゲーム終了！敗者は${remainingPlayers[0].name}です。`);
  //     setFinishedPlayers([...finishedPlayers, remainingPlayers[0].id]);
  //     setGameStarted(false);
  //     return;
  //   }

  //   if (currentPlayer.id === 0) {
  //     console.log("プレーヤーがカードを取ってください。");
  //   } else {
  //     // Find the next non-winning player
  //     let nextPlayerIndex = (turnPlayer + 1) % players.length;
  //     while (remainingPlayers.indexOf(players[nextPlayerIndex]) === -1) {
  //       nextPlayerIndex = (nextPlayerIndex + 1) % players.length;
  //     }

  //     console.log(`コンピューター${turnPlayer}がプレイヤー${nextPlayerIndex}からカードを取ります。`);
  //     setTimeout(() => {
  //       getCardComputer(nextPlayerIndex);
  //       setTimeout(() => {
  //         throwCardComputer();
  //       }, 100);
  //     }, 100);
  //   }
  // };

  // const getCardComputer = (targetPlayerIndex) => {
  //   // Check if targetPlayerIndex is within the range of players array
  //   if (targetPlayerIndex >= players.length) return;

  //   const selectedCardIndex = Math.floor(Math.random() * players[targetPlayerIndex].hand.length);
  //   const selectedCard = players[targetPlayerIndex].hand[selectedCardIndex];

  //   // Check if the selectedCard is undefined
  //   if (!selectedCard) return;

  //   const currentPlayer = players[turnPlayer];
  //   const newPlayerHand = [...currentPlayer.hand, selectedCard]; // Add the selected card to the player's hand
  //   const handWithoutPairs = removePairs(newPlayerHand); // Remove pairs from the new hand

  //   const newPlayers = players.map((player, index) => {
  //     if (index === turnPlayer) {
  //       return { ...player, hand: handWithoutPairs };
  //     } else if (index === targetPlayerIndex) {
  //       return {
  //         ...player,
  //         hand: player.hand.filter((_, i) => i !== selectedCardIndex),
  //       };
  //     } else {
  //       return player;
  //     }
  //   });
  //   console.log(`コンピューター${turnPlayer}がプレイヤー${targetPlayerIndex}から${selectedCard.value}の${selectedCard.suit}を取りました。`);
  //   setPlayers(newPlayers);
  // };

  // const removePairs = (hand, player) => {
  //   const handWithPairsRemoved = [];
  //   const valueCounts = {};

  //   // Count the occurrences of each card value
  //   hand.forEach((card) => {
  //     if (card && valueCounts[card.value]) {
  //       valueCounts[card.value]++;
  //     } else if (card) {
  //       valueCounts[card.value] = 1;
  //     }
  //   });
  //   // Iterate through the hand and add cards to handWithPairsRemoved if the value count is not even
  //   hand.forEach((card) => {
  //     if (card && valueCounts[card.value] % 2 !== 0) {
  //       handWithPairsRemoved.push(card);
  //       valueCounts[card.value]--;
  //     }
  //   });

  //   const pairs = hand.filter((card) => valueCounts[card.value] === 0);

  //   if (pairs.length > 0) {
  //     console.log('pairs:', pairs); // ペアが削除されたカードを確認
  //   }

  //   if (player) {
  //     player.removedPairs.push(...pairs); // 各プレイヤーの removedPairs 配列に追加
  //   }

  //   return handWithPairsRemoved;
  // };
  // const throwCardComputer = () => {
  //   const currentPlayer = players[turnPlayer];
  //   const newHand = [...currentPlayer.hand];
  //   const handWithoutPairs = removePairs(newHand);

  //   // If pairs have been removed, discard a random card
  //   if (handWithoutPairs.length < newHand.length) {
  //     const selectedCardIndex = Math.floor(Math.random() * currentPlayer.hand.length);
  //     newHand.splice(selectedCardIndex, 1);

  //     const newPlayers = players.map((player, index) => {
  //       if (index === turnPlayer) {
  //         return { ...player, hand: newHand };
  //       } else {
  //         return player;
  //       }
  //     });
  //     console.log(`コンピューター${turnPlayer}がカードを捨てます。`);

  //     setPlayers(newPlayers);
  //   }

  //   // Move to the next player
  //   setTurnPlayer((turnPlayer + 1) % 4);
  // };


  // const clickCard = (handIndex, cardIndex) => {
  //   if (turnPlayer !== 0 || handIndex === 0) {
  //     return;
  //   }

  //   const selectedCard = players[handIndex].hand[cardIndex];
  //   const newPlayerHand = [...players[0].hand, selectedCard];
  //   const handWithoutPairs = removePairs(newPlayerHand);

  //   const newPlayers = players.map((player, index) => {
  //     if (index === 0) {
  //       return { ...player, hand: handWithoutPairs };
  //     } else if (index === handIndex) {
  //       return {
  //         ...player,
  //         hand: player.hand.filter((_, i) => i !== cardIndex),
  //       };
  //     } else {
  //       return player;
  //     }
  //   });

  //   setPlayers(newPlayers);
  //   // Move to the next player
  //   setTurnPlayer((turnPlayer + 1) % 4);

  // };


  // useEffect(() => {
  //   if (gameStarted && turnPlayer !== null) {
  //     executeNextPlayer();
  //     console.log("players" + JSON.stringify(players))
  //   }
  // }, [turnPlayer, gameStarted]);


  const onStartGame = async () => {
    try {
      console.log('onStartGame');
      const web3 = new Web3("http://localhost:8545");
      const senderAddress = "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266"
      const contractInstance = new web3.eth.Contract(CONTRACT_ABI.abi, CONTRACT_ADDRESS);

      const res = await contractInstance.methods.sayHello().call();
      console.log('Response from smart contract:', res);
      // await contractInstance.methods.joinGameBatch(accounts).send().then(function (receipt) {
      //   console.log("Players have joined the game:", receipt);
      // }).catch(function (error) {
      //   console.error("Failed to join the game:", error);
      // });
      // const res2 = await contractInstance.methods.PLAYER_COUNT().call();
      // console.log('Response from PLAYER_COUNT:', res2);

      // const tx = await contractInstance.methods.startGame().send().then(function (receipt) {
      //   console.log("Game started:", receipt);
      // }).catch(function (error) {
      //   console.error("Failed to start the game:", error);
      // });
      // console.log("tx" + JSON.stringify(tx))
    } catch (error) {
      console.error('Error executing smart contract function:', error);
    }

  };


  // const onResetGame = async () => {
  //   try {
  //     await contractInstance.methods.resetGame().send();
  //   } catch (error) {
  //     console.error("Error executing smart contract function:", error);
  //   }
  // };


  // const renderResetButton = () => {
  //   return (
  //     <Button onClick={onResetGame} disabled={!gameStarted}>
  //       Reset Game
  //     </Button>
  //   );
  // };

  // useEffect(() => {
  //   const onGameStarted = (error, event) => {
  //     if (!error) {
  //       const player1Address = event.returnValues[0];
  //       const player2Address = event.returnValues[1];
  //       const player3Address = event.returnValues[2];
  //       const player4Address = event.returnValues[3];
  //       const player1Hand = event.returnValues[4];
  //       const player2Hand = event.returnValues[5];
  //       const player3Hand = event.returnValues[6];
  //       const player4Hand = event.returnValues[7];
  //       setPlayers([
  //         { id: 0, name: 'Player 1', hand: player1Hand, removedPairs: [] },
  //         { id: 1, name: 'Player 2', hand: player2Hand, removedPairs: [] },
  //         { id: 2, name: 'Player 3', hand: player3Hand, removedPairs: [] },
  //         { id: 3, name: 'Player 4', hand: player4Hand, removedPairs: [] },
  //       ]);
  //       setGameStarted(true);
  //       setTurnPlayer(0);
  //     } else {
  //       console.error(error);
  //     }
  //   };
  // }, []);


  const renderPlayerHand = (player) => {
    return (
      <div>
        <h2>{player.name}</h2>
        <Table striped bordered hover>
          <thead>
            <tr>
              <th>Card Value</th>
              <th>Suit</th>
            </tr>
          </thead>
          <tbody>
            {player.hand.map((card, index) => {
              return (
                <tr key={index}>
                  <td>{card.value}</td>
                  <td>{card.suit}</td>
                </tr>
              );
            })}
          </tbody>
        </Table>
      </div>
    );
  };

  const renderStartButton = () => {
    return (
      <Container>
        <Row>
          <Col>
            <Button onClick={onStartGame} disabled={gameStarted}>
              Start Game
            </Button>
          </Col>
        </Row>
      </Container>
    );
  };


  return (
    <Container>
      <Row>
        <Col>
          {renderStartButton()}
          {/* {renderResetButton()} */}
        </Col>
      </Row>
      {gameStarted && (
        <Row>
          {players.map((player) => (
            <Col key={player.id}>
              {renderPlayerHand(player)}
            </Col>
          ))}
        </Row>
      )}
    </Container>
  )
};

export default App;