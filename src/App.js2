import React, { useState, useEffect } from 'react';
import { Button, Container, Row, Col, Table } from 'react-bootstrap';
import CONTRACT_ADDRESS from './config/contract-address';
import CONTRACT_ABI from './config/BabanukiNFT.json';
import Web3 from 'web3';

// web3Instance.jsで作成したWeb3インスタンスをインポート
//import web3 from './lib/web3Instance';


const App = () => {
  const [players, setPlayers] = useState([]);
  const [gameStarted, setGameStarted] = useState(false);
  const [turnPlayer, setTurnPlayer] = useState(null);
  const [finishedPlayers, setFinishedPlayers] = useState([]);
  const [remainingPlayers, setRemainingPlayers] = useState([]);

  const createDeck = () => {
    const suits = ['hearts', 'diamonds', 'clubs', 'spades'];
    const values = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
    const deck = [];
    for (let i = 0; i < suits.length; i++) {
      for (let j = 0; j < values.length; j++) {
        deck.push({ suit: suits[i], value: values[j] });
      }
    }
    deck.push({ suit: 'joker', value: 'joker' });
    return deck;
  };

  const shuffleDeck = (deck) => {
    for (let i = deck.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [deck[i], deck[j]] = [deck[j], deck[i]];
    }
    return deck;
  };

  const dealCards = (deck) => {
    const playerNames = ['Player', 'NPC1', 'NPC2', 'NPC3'];
    const players = playerNames.map((name, index) => {
      const handSize = index === playerNames.length - 1 ? 14 : 13;
      let hand = deck.splice(0, handSize);
      // 手札が空のプレーヤーを除外する
      if (hand.length === 0) {
        console.log(`${name}の手札が空です。`);
        return null;
      }
      return { id: index, name, hand, removedPairs: [] };
    }).filter(player => player !== null); // nullを除外する
    const playersWithRemovedPairs = players.map((player) => {
      return { ...player, hand: removePairs(player.hand) };
    });

    setPlayers(playersWithRemovedPairs);
    return playersWithRemovedPairs;
  };

  const executeNextPlayer = () => {
    const currentPlayer = players[turnPlayer];
    if (currentPlayer.hand.length === 0) {
      // Save the first player who has no more cards
      if (finishedPlayers.length === 0) {
        setFinishedPlayers([currentPlayer.id]);
      }
      // Move to the next player
      setTurnPlayer((turnPlayer + 1) % players.length);
      return;
    }
    // Find players who have not yet won
    const remainingPlayers = players.filter(player => player.hand.length > 0);
    if (remainingPlayers.length === 1) {
      console.log(`ゲーム終了！敗者は${remainingPlayers[0].name}です。`);
      setFinishedPlayers([...finishedPlayers, remainingPlayers[0].id]);
      setGameStarted(false);
      return;
    }

    if (currentPlayer.id === 0) {
      console.log("プレーヤーがカードを取ってください。");
    } else {
      // Find the next non-winning player
      let nextPlayerIndex = (turnPlayer + 1) % players.length;
      while (remainingPlayers.indexOf(players[nextPlayerIndex]) === -1) {
        nextPlayerIndex = (nextPlayerIndex + 1) % players.length;
      }

      console.log(`コンピューター${turnPlayer}がプレイヤー${nextPlayerIndex}からカードを取ります。`);
      setTimeout(() => {
        getCardComputer(nextPlayerIndex);
        setTimeout(() => {
          throwCardComputer();
        }, 100);
      }, 100);
    }
  };

  const getCardComputer = (targetPlayerIndex) => {
    // Check if targetPlayerIndex is within the range of players array
    if (targetPlayerIndex >= players.length) return;

    const selectedCardIndex = Math.floor(Math.random() * players[targetPlayerIndex].hand.length);
    const selectedCard = players[targetPlayerIndex].hand[selectedCardIndex];

    // Check if the selectedCard is undefined
    if (!selectedCard) return;

    const currentPlayer = players[turnPlayer];
    const newPlayerHand = [...currentPlayer.hand, selectedCard]; // Add the selected card to the player's hand
    const handWithoutPairs = removePairs(newPlayerHand); // Remove pairs from the new hand

    const newPlayers = players.map((player, index) => {
      if (index === turnPlayer) {
        return { ...player, hand: handWithoutPairs };
      } else if (index === targetPlayerIndex) {
        return {
          ...player,
          hand: player.hand.filter((_, i) => i !== selectedCardIndex),
        };
      } else {
        return player;
      }
    });
    console.log(`コンピューター${turnPlayer}がプレイヤー${targetPlayerIndex}から${selectedCard.value}の${selectedCard.suit}を取りました。`);
    setPlayers(newPlayers);
  };

  const throwCardComputer = () => {
    const currentPlayer = players[turnPlayer];
    const newHand = [...currentPlayer.hand];
    const handWithoutPairs = removePairs(newHand);

    // If pairs have been removed, discard a random card
    if (handWithoutPairs.length < newHand.length) {
      const selectedCardIndex = Math.floor(Math.random() * currentPlayer.hand.length);
      newHand.splice(selectedCardIndex, 1);

      const newPlayers = players.map((player, index) => {
        if (index === turnPlayer) {
          return { ...player, hand: newHand };
        } else {
          return player;
        }
      });
      console.log(`コンピューター${turnPlayer}がカードを捨てます。`);

      setPlayers(newPlayers);
    }

    // Move to the next player
    setTurnPlayer((turnPlayer + 1) % 4);
  };


  const clickCard = (handIndex, cardIndex) => {
    if (turnPlayer !== 0 || handIndex === 0) {
      return;
    }

    const selectedCard = players[handIndex].hand[cardIndex];
    const newPlayerHand = [...players[0].hand, selectedCard];
    const handWithoutPairs = removePairs(newPlayerHand);

    const newPlayers = players.map((player, index) => {
      if (index === 0) {
        return { ...player, hand: handWithoutPairs };
      } else if (index === handIndex) {
        return {
          ...player,
          hand: player.hand.filter((_, i) => i !== cardIndex),
        };
      } else {
        return player;
      }
    });

    setPlayers(newPlayers);
    // Move to the next player
    setTurnPlayer((turnPlayer + 1) % 4);

  };


  const discardPairs = (players) => {
    const newPlayers = players.map((player) => {
      const handWithoutPairs = removePairs(player.hand, player);
      return { ...player, hand: handWithoutPairs };
    });
    setPlayers(newPlayers);
  }
  const removePairs = (hand, player) => {
    const handWithPairsRemoved = [];
    const valueCounts = {};

    // Count the occurrences of each card value
    hand.forEach((card) => {
      if (card && valueCounts[card.value]) {
        valueCounts[card.value]++;
      } else if (card) {
        valueCounts[card.value] = 1;
      }
    });

    // Iterate through the hand and add cards to handWithPairsRemoved if the value count is not even
    hand.forEach((card) => {
      if (card && valueCounts[card.value] % 2 !== 0) {
        handWithPairsRemoved.push(card);
        valueCounts[card.value]--;
      }
    });

    const pairs = hand.filter((card) => valueCounts[card.value] === 0);

    if (pairs.length > 0) {
      console.log('pairs:', pairs); // ペアが削除されたカードを確認
    }

    if (player) {
      player.removedPairs.push(...pairs); // 各プレイヤーの removedPairs 配列に追加
    }

    return handWithPairsRemoved;
  };


  useEffect(() => {
    if (gameStarted && turnPlayer !== null) {
      executeNextPlayer();
      console.log("players" + JSON.stringify(players))
    }
  }, [turnPlayer, gameStarted]);


  const onStartGame = async () => {
    // const deck = shuffleDeck(createDeck());
    // const newPlayers = dealCards(deck);
    // discardPairs(newPlayers);
    // setGameStarted(true);
    // // Randomly determine the first player
    // const firstPlayer = Math.floor(Math.random() * 4);
    // setTurnPlayer(firstPlayer);

    // try {
    // const accounts = [
    //   "0x15d34AAf54267DB7D7c367839AAf71A00a2C6A65",
    //   "0x70997970C51812dc3A010C7d01b50e0d17dc79C8",
    //   "0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC",
    //   "0x90F79bf6EB2c4f870365E785982E1f101E93b906",
    // ];
    // const account = accounts[0];
    // console.log(account);
    //   const web3 = new Web3("http://localhost:8545");
    //   const contractInstance = new web3.eth.Contract(CONTRACT_ABI.abi, CONTRACT_ADDRESS);
    //   const res = await contractInstance.methods.sayHello().call();
    //   console.log("Response from smart contract:", res);
    //   // const result = await contractInstance.methods.startGame().send({ from: account });
    //   // console.log('Transaction successful:', result);
    // } catch (error) {
    //   console.error('Transaction failed:', error);
    // }


    try {
      const web3 = new Web3("http://localhost:8545");
      const contractInstance = new web3.eth.Contract(CONTRACT_ABI.abi, CONTRACT_ADDRESS);
      const res = await contractInstance.methods.sayHello().call();
      console.log('Response from smart contract:', res);
    } catch (error) {
      console.error('Error executing smart contract function:', error);
    }
  };


  const renderTable = (player, playerIndex) => (
    <>
      <Table striped bordered hover>
        <thead>
          <tr>
            {player.hand.map((card, index) => (
              <th key={index}>{card.value}</th>
            ))}
          </tr>
        </thead>
        <tbody>
          <tr>
            {player.hand.map((card, index) => (
              <td
                key={index}
                onClick={() => clickCard(playerIndex, index)}
              >
                {card.suit}
              </td>
            ))}
          </tr>
        </tbody>
      </Table>
      {renderRemovedPairsTable(player)}
    </>
  );


  const renderRemovedPairsTable = (player) => {
    if (!player.removedPairs || player.removedPairs.length === 0) return null;

    return (
      <Table striped bordered hover>
        <thead>
          <tr>
            <th>Value</th>
            <th>Suit</th>
          </tr>
        </thead>
        <tbody>
          {player.removedPairs.map((card, index) => (
            <tr key={index}>
              <td>{card.value}</td>
              <td>{card.suit}</td>
            </tr>
          ))}
        </tbody>
      </Table>
    );
  };


  const renderStartButton = () => {
    return (
      <Container>
        <Row>
          <Col>
            <Button onClick={onStartGame} disabled={gameStarted}>
              Start Game
            </Button>
          </Col>
        </Row>
      </Container>
    );
  };
  return (
    <Container>
      <Row>
        <Col>
          {renderStartButton()}
        </Col>
      </Row>
      {gameStarted && (
        <Row>
          {players.map((player, index) => (
            <Col key={player.id}>
              <h4>{player.name}</h4>
              {player.hand.length > 0 && renderTable(player, index)}
            </Col>
          ))}
        </Row>
      )}
      {finishedPlayers.length > 0 && (
        <Row>
          <Col>
            {players.map((player) => {
              if (finishedPlayers.includes(player.id)) {
                return <p key={player.id}>{player.name}</p>;
              }
            })}
          </Col>
        </Row>
      )}
      {remainingPlayers.length === 1 && (
        <Row>
          <Col>
            {players.map((player) => {
              if (!finishedPlayers.includes(player.id)) {
                return <p key={player.id}>{player.name}</p>;
              }
            })}
          </Col>
        </Row>
      )}
    </Container>
  );

};

export default App;