import React, { useState, useEffect } from 'react';
import { Button, Container, Row, Col, Table } from 'react-bootstrap';
import CONTRACT_ADDRESS from './config/contract-address';
import CONTRACT_ABI from './config/BabanukiNFT.json';
import Web3 from 'web3';

// web3Instance.jsで作成したWeb3インスタンスをインポート
//import web3 from './lib/web3Instance';


const App = () => {
  const [players, setPlayers] = useState([]);
  const [turnPlayer, setTurnPlayer] = useState(null);
  const [finishedPlayers, setFinishedPlayers] = useState([]);
  const [remainingPlayers, setRemainingPlayers] = useState([]);
  const [playerData, setPlayerData] = useState([]);
  const [gameStarted, setGameStarted] = useState(false);

  const accounts = [
    "0x15d34AAf54267DB7D7c367839AAf71A00a2C6A65",
    "0x70997970C51812dc3A010C7d01b50e0d17dc79C8",
    "0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC",
    "0x90F79bf6EB2c4f870365E785982E1f101E93b906",
  ];


  // const executeNextPlayer = () => {
  //   const currentPlayer = players[turnPlayer];
  //   if (currentPlayer.hand.length === 0) {
  //     // Save the first player who has no more cards
  //     if (finishedPlayers.length === 0) {
  //       setFinishedPlayers([currentPlayer.id]);
  //     }
  //     // Move to the next player
  //     setTurnPlayer((turnPlayer + 1) % players.length);
  //     return;
  //   }
  //   // Find players who have not yet won
  //   const remainingPlayers = players.filter(player => player.hand.length > 0);
  //   if (remainingPlayers.length === 1) {
  //     console.log(`ゲーム終了！敗者は${remainingPlayers[0].name}です。`);
  //     setFinishedPlayers([...finishedPlayers, remainingPlayers[0].id]);
  //     setGameStarted(false);
  //     return;
  //   }

  //   if (currentPlayer.id === 0) {
  //     console.log("プレーヤーがカードを取ってください。");
  //   } else {
  //     // Find the next non-winning player
  //     let nextPlayerIndex = (turnPlayer + 1) % players.length;
  //     while (remainingPlayers.indexOf(players[nextPlayerIndex]) === -1) {
  //       nextPlayerIndex = (nextPlayerIndex + 1) % players.length;
  //     }

  //     console.log(`コンピューター${turnPlayer}がプレイヤー${nextPlayerIndex}からカードを取ります。`);
  //     setTimeout(() => {
  //       getCardComputer(nextPlayerIndex);
  //       setTimeout(() => {
  //         throwCardComputer();
  //       }, 100);
  //     }, 100);
  //   }
  // };

  // const getCardComputer = (targetPlayerIndex) => {
  //   // Check if targetPlayerIndex is within the range of players array
  //   if (targetPlayerIndex >= players.length) return;

  //   const selectedCardIndex = Math.floor(Math.random() * players[targetPlayerIndex].hand.length);
  //   const selectedCard = players[targetPlayerIndex].hand[selectedCardIndex];

  //   // Check if the selectedCard is undefined
  //   if (!selectedCard) return;

  //   const currentPlayer = players[turnPlayer];
  //   const newPlayerHand = [...currentPlayer.hand, selectedCard]; // Add the selected card to the player's hand
  //   const handWithoutPairs = removePairs(newPlayerHand); // Remove pairs from the new hand

  //   const newPlayers = players.map((player, index) => {
  //     if (index === turnPlayer) {
  //       return { ...player, hand: handWithoutPairs };
  //     } else if (index === targetPlayerIndex) {
  //       return {
  //         ...player,
  //         hand: player.hand.filter((_, i) => i !== selectedCardIndex),
  //       };
  //     } else {
  //       return player;
  //     }
  //   });
  //   console.log(`コンピューター${turnPlayer}がプレイヤー${targetPlayerIndex}から${selectedCard.value}の${selectedCard.suit}を取りました。`);
  //   setPlayers(newPlayers);
  // };

  // const removePairs = (hand, player) => {
  //   const handWithPairsRemoved = [];
  //   const valueCounts = {};

  //   // Count the occurrences of each card value
  //   hand.forEach((card) => {
  //     if (card && valueCounts[card.value]) {
  //       valueCounts[card.value]++;
  //     } else if (card) {
  //       valueCounts[card.value] = 1;
  //     }
  //   });
  //   // Iterate through the hand and add cards to handWithPairsRemoved if the value count is not even
  //   hand.forEach((card) => {
  //     if (card && valueCounts[card.value] % 2 !== 0) {
  //       handWithPairsRemoved.push(card);
  //       valueCounts[card.value]--;
  //     }
  //   });

  //   const pairs = hand.filter((card) => valueCounts[card.value] === 0);

  //   if (pairs.length > 0) {
  //     console.log('pairs:', pairs); // ペアが削除されたカードを確認
  //   }

  //   if (player) {
  //     player.removedPairs.push(...pairs); // 各プレイヤーの removedPairs 配列に追加
  //   }

  //   return handWithPairsRemoved;
  // };
  // const throwCardComputer = () => {
  //   const currentPlayer = players[turnPlayer];
  //   const newHand = [...currentPlayer.hand];
  //   const handWithoutPairs = removePairs(newHand);

  //   // If pairs have been removed, discard a random card
  //   if (handWithoutPairs.length < newHand.length) {
  //     const selectedCardIndex = Math.floor(Math.random() * currentPlayer.hand.length);
  //     newHand.splice(selectedCardIndex, 1);

  //     const newPlayers = players.map((player, index) => {
  //       if (index === turnPlayer) {
  //         return { ...player, hand: newHand };
  //       } else {
  //         return player;
  //       }
  //     });
  //     console.log(`コンピューター${turnPlayer}がカードを捨てます。`);

  //     setPlayers(newPlayers);
  //   }

  //   // Move to the next player
  //   setTurnPlayer((turnPlayer + 1) % 4);
  // };


  // const clickCard = (handIndex, cardIndex) => {
  //   if (turnPlayer !== 0 || handIndex === 0) {
  //     return;
  //   }

  //   const selectedCard = players[handIndex].hand[cardIndex];
  //   const newPlayerHand = [...players[0].hand, selectedCard];
  //   const handWithoutPairs = removePairs(newPlayerHand);

  //   const newPlayers = players.map((player, index) => {
  //     if (index === 0) {
  //       return { ...player, hand: handWithoutPairs };
  //     } else if (index === handIndex) {
  //       return {
  //         ...player,
  //         hand: player.hand.filter((_, i) => i !== cardIndex),
  //       };
  //     } else {
  //       return player;
  //     }
  //   });

  //   setPlayers(newPlayers);
  //   // Move to the next player
  //   setTurnPlayer((turnPlayer + 1) % 4);

  // };


  // useEffect(() => {
  //   if (gameStarted && turnPlayer !== null) {
  //     executeNextPlayer();
  //     console.log("players" + JSON.stringify(players))
  //   }
  // }, [turnPlayer, gameStarted]);






  useEffect(() => {
    if (gameStarted && turnPlayer !== null) {
      executeNextPlayer();
    }
  }, [turnPlayer, gameStarted]);

  const onStartGame = async () => {
    try {
      console.log('onStartGame');
      const web3 = new Web3("ws://localhost:8545");
      const senderAddress = "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266"
      const contractInstance = new web3.eth.Contract(CONTRACT_ABI.abi, CONTRACT_ADDRESS);

      const res = await contractInstance.methods.sayHello().call();
      console.log('Response from smart contract:', res);

      const numberOfPlayers = await contractInstance.methods.getNumberOfPlayers().call();
      if (numberOfPlayers <= 4) {
        await contractInstance.methods.joinGameBatch(accounts).send({ from: senderAddress }).then(function (receipt) {
          console.log("Players have joined the game:", receipt);
        }).catch(function (error) {
          console.error("Failed to join the game:", error);
        });
      }
    } catch (error) {
      console.error('Error executing smart contract function:', error);
    }
    try {
      const web3 = new Web3("ws://localhost:8545");
      const senderAddress = "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266"
      const contractInstance = new web3.eth.Contract(CONTRACT_ABI.abi, CONTRACT_ADDRESS);
      await contractInstance.methods.startGame().send({ from: senderAddress }).then(function (receipt) {
        console.log("Game started:", receipt);
      }).catch(function (error) {
        console.error("Failed to start the game:", error);
      });
    } catch (error) {
      if (error.message.includes("Game has already started.")) {
        // Display a user-friendly message, e.g., using an alert or updating the UI
        alert("The game has already started.");
      } else {
        console.error(error);
      }
    }
  };

  function convertToCardsArray(hand) {
    console.log(hand)
    let suit = hand.charAt(0);
    let rank = hand.substring(1);
    if (suit === "0") {
      return;
    }
    switch (suit) {
      case "1":
        suit = "Spades";
        break;
      case "2":
        suit = "Hearts";
        break;
      case "3":
        suit = "Clubs";
        break;
      case "4":
        suit = "Diamonds";
        break;
      case "9":
        suit = "Joker";
        rank = "";
        break;
      default:
        throw new Error(`Invalid suit: ${suit}`);
    }

    switch (rank) {
      case "01":
        rank = "Ace";
        break;
      case "11":
        rank = "Jack";
        break;
      case "12":
        rank = "Queen";
        break;
      case "13":
        rank = "King";
        break;
      default:
        rank = parseInt(rank, 10).toString();
    }
    const card = { suit: suit, rank: rank }
    return card;
  }






  useEffect(() => {
    const web3 = new Web3("ws://localhost:8545");
    const contractInstance = new web3.eth.Contract(CONTRACT_ABI.abi, CONTRACT_ADDRESS);


    contractInstance.events.GameStarted({}, (error, event) => {
      if (!error) {
        const playerAddresses = [
          event.returnValues.player1,
          event.returnValues.player2,
          event.returnValues.player3,
          event.returnValues.player4,
        ];

        const playerHands = [
          event.returnValues.player1Hand,
          event.returnValues.player2Hand,
          event.returnValues.player3Hand,
          event.returnValues.player4Hand,
        ];
        const filteredPlayerHands = playerHands.map(hand =>
          hand.filter(card => card !== '0')
        );
        const newPlayerData = playerAddresses.map((address, index) => {
          return {
            id: index,
            name: `Player ${index + 1}`,
            hand: filteredPlayerHands[index]
          };
        });
        setPlayerData(newPlayerData);
        setGameStarted(true);
      } else {
        console.error(error);
      }
    });

  }, []);



  const onResetGame = async () => {
    try {
      const senderAddress = "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266"
      const web3 = new Web3("ws://localhost:8545");
      const contractInstance = new web3.eth.Contract(CONTRACT_ABI.abi, CONTRACT_ADDRESS);
      await contractInstance.methods.resetGame().send({ from: senderAddress });
    } catch (error) {
      console.error("Error executing smart contract function:", error);
    }
  };



  // Render the player hands based on the playerData state
  const renderPlayerHand = (player) => {
    return (
      <div>
        <h2>{player.name}</h2>
        <Table striped bordered hover>
          <thead>
            <tr>
              <th>Card Value</th>
              <th>Suit</th>
            </tr>
          </thead>
          <tbody>
            {player.hand.map((card, index) => {
              console.log('card:', card);
              const convertedCard = convertToCardsArray(card);
              console.log(convertedCard);
              return (
                <tr key={index}>
                  <td>{convertedCard.rank}</td>
                  <td>{convertedCard.suit}</td>
                </tr>
              );
            })}
          </tbody>
        </Table>
      </div>
    );
  };


  const renderStartButton = () => {
    return (
      <Container>
        <Row>
          <Col>
            <Button onClick={onStartGame}>
              Start Game
            </Button>
          </Col>
        </Row>
      </Container>
    );
  };
  const renderResetButton = () => {
    return (
      <Button onClick={onResetGame} >
        Reset Game
      </Button>
    );
  };

  return (
    <Container>
      <Row>
        <Col>
          {renderStartButton()}
          {renderResetButton()}
        </Col>
      </Row>
      {gameStarted && (
        <Row>
          {playerData.map((player) => (
            <Col key={player.id}>
              {renderPlayerHand(player)}
            </Col>
          ))}
        </Row>
      )}
    </Container>
  )
};

export default App;